package 小灰.树;

/**
 * 二叉树
 * 
 * 实现方式1：链表
 * data, left-node, right-node
 * 
 * 实现方式2：数组 - 不适合稀疏二叉树，浪费空间
 * 按层级顺序将节点数据存储顺序存储到数组，空缺的孩子节点在数组中对应位置也空出
 * 
 * 
 * 【二叉树的应用】
 * 
 * 1、查找
 * 
 * 【二叉查找树】 - 依靠比较大小来逐步查找（类似于二分查找） - 时间复杂度 O(logn)
 * - 左子树的值都比根节点的值小
 * - 右子树的值都比根节点的值大
 * - 左右子树也都是二叉查找树
 * -【以上特性 保证了二叉树的`有序性`】
 * 
 * 2、维持相对顺序
 * 二叉查找树 另一个名字 【二叉排序树】 - 看上面列出的二叉查找树的特性
 * 
 * 
 * 【存在问题】
 * 
 * 例如数据：10[根节点] 9 8 7 6 5 4 3 2 1
 * 会导致所有节点全部在左侧，而且时间复杂度也变成了O(n)
 * 
 * 【解决问题】
 * 
 * [二叉树的自平衡] 方式：红黑树、AVL树、树堆等等
 * 
 * 
 * 【还有 - 二叉堆】
 * 
 * 像二叉排序树一样，[但是只要求父节点比它的左右孩子大即可]
 */
public class BinaryTree {
    public static void main(String[] args) {

    }
}
